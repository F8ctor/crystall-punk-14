using System.Linq;
using System.Numerics;
using Content.Shared._CP14.Skill.Components;
using Content.Shared._CP14.Skill.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Input;
using Robust.Shared.Prototypes;

namespace Content.Client._CP14.Skill.Ui;

[GenerateTypedNameReferences]
public sealed partial class CP14SkillTreeGraphControl : BoxContainer
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _proto = default!;

    private readonly CP14SkillTreePrototype? _tree;

    private Entity<CP14SkillStorageComponent>? _player;

    private IEnumerable<CP14SkillPrototype> _allSkills;

    private CP14SkillPrototype? _hoveredNode;
    private CP14SkillPrototype? _selectedNode;

    private float GridSize = 25f;

    public event Action<CP14SkillPrototype?>? OnNodeSelected;

    public CP14SkillTreeGraphControl()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _allSkills = _proto.EnumeratePrototypes<CP14SkillPrototype>();
        _proto.PrototypesReloaded += _ => _allSkills = _proto.EnumeratePrototypes<CP14SkillPrototype>();

        _tree = _proto.Index<CP14SkillTreePrototype>("Blacksmithing");
    }

    public void SetPlayer(Entity<CP14SkillStorageComponent>? player)
    {
        _player = player;
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Handled || args.Function != EngineKeyFunctions.UIClick)
            return;

        if (_hoveredNode == null)
            return;

        OnNodeSelected?.Invoke(_hoveredNode);
        UserInterfaceManager.ClickSound();
        _selectedNode = _hoveredNode;
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        OnNodeSelected?.Invoke(null);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        _hoveredNode = null;
        if (_player == null || _tree == null)
        {
            return;
        }

        var cursor = (UserInterfaceManager.MousePositionScaled.Position * UIScale) - GlobalPixelPosition;
        var playerSkills = _player.Value.Comp.Skills;

        var globalOffset = new Vector2(60, 60);

        //Draw connection lines
        foreach (var skill in _allSkills)
        {
            if (skill.Tree != _tree)
                continue;

            var learned = playerSkills.Contains(skill.ID);
            var canBeLearned = learned || skill.Prerequisites.All(prerequisite => playerSkills.Contains(prerequisite));

            var fromPos = skill.SkillUiPosition * GridSize * UIScale + globalOffset;

            foreach (var prerequisite in skill.Prerequisites)
            {
                if (!_proto.TryIndex(prerequisite, out var prerequisiteSkill))
                    continue;

                var toPos = prerequisiteSkill.SkillUiPosition * GridSize * UIScale + globalOffset;
                var color = canBeLearned ? Color.White : Color.FromSrgb(new Color(0.7f, 0.7f, 0.7f));
                handle.DrawLine(fromPos, toPos, color);
            }
        }

        //Draw skill icons over lines
        foreach (var skill in _allSkills)
        {
            if (skill.Tree != _tree)
                continue;

            var learned = playerSkills.Contains(skill.ID);
            var canBeLearned = learned || skill.Prerequisites.All(prerequisite => playerSkills.Contains(prerequisite));
            var pos = skill.SkillUiPosition * GridSize * UIScale + globalOffset;

            // Base skill icon
            var baseTexture = skill.Icon.Frame0();
            var baseSize = new Vector2(baseTexture.Width, baseTexture.Height) * 2;
            var baseQuad = new UIBox2(pos - baseSize / 2, pos + baseSize / 2);

            var hovered = (cursor - pos).LengthSquared() <= (baseSize.X / 2) * (baseSize.X / 2);

            // Frame
            var frameTexture = _tree.FrameIcon.Frame0();
            var frameSize = new Vector2(frameTexture.Width, frameTexture.Height) * 2;
            var frameQuad = new UIBox2(pos - frameSize / 2, pos + frameSize / 2);
            handle.DrawTextureRect(frameTexture, frameQuad, canBeLearned ? Color.White : Color.FromSrgb(new Color(0.7f, 0.7f, 0.7f)));

            // Selected Skill
            if (_selectedNode == skill)
            {
                var selectedTexture = _tree.SelectedIcon.Frame0();
                var selectedSize = new Vector2(selectedTexture.Width, selectedTexture.Height) * 2;
                var selectedQuad = new UIBox2(pos - selectedSize / 2, pos + selectedSize / 2);
                handle.DrawTextureRect(selectedTexture, selectedQuad, Color.White);
            }

            // Hovered Skill
            if (hovered)
            {
                _hoveredNode = skill;
                var hoveredTexture = _tree.HoveredIcon.Frame0();
                var hoveredSize = new Vector2(hoveredTexture.Width, hoveredTexture.Height) * 2;
                var hoveredQuad = new UIBox2(pos - hoveredSize / 2, pos + hoveredSize / 2);
                handle.DrawTextureRect(hoveredTexture, hoveredQuad, Color.White);
            }

            //Learned Skill
            if (learned)
            {
                var learnedTexture = _tree.LearnedIcon.Frame0();
                var learnedSize = new Vector2(learnedTexture.Width, learnedTexture.Height) * 2;
                var learnedQuad = new UIBox2(pos - learnedSize / 2, pos + learnedSize / 2);
                handle.DrawTextureRect(learnedTexture, learnedQuad, Color.White);
            }

            // Отрисовка основной иконки поверх
            var iconColor = Color.White;
            if (!learned)
                iconColor = Color.FromSrgb(new Color(0.7f, 0.7f, 0.7f));
            if (!canBeLearned && !learned)
                iconColor = Color.FromSrgb(new Color(0f, 0f, 0f));

            handle.DrawTextureRect(baseTexture, baseQuad, iconColor);
        }
    }
}
