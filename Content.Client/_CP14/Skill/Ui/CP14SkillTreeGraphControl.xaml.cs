using System.Numerics;
using Content.Shared._CP14.Skill.Components;
using Content.Shared._CP14.Skill.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Prototypes;

namespace Content.Client._CP14.Skill.Ui;

[GenerateTypedNameReferences]
public sealed partial class CP14SkillTreeGraphControl : BoxContainer
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _proto = default!;

    private readonly CP14SkillTreePrototype? _tree;

    private Entity<CP14SkillStorageComponent>? _player;

    private IEnumerable<CP14SkillPrototype> _allSkills;

    private CP14SkillPrototype? _hoveredNode;
    private CP14SkillPrototype? _selectedNode;

    private float GridSize = 25f;

    public event Action<CP14SkillPrototype>? OnNodeSelected;

    public CP14SkillTreeGraphControl()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _allSkills = _proto.EnumeratePrototypes<CP14SkillPrototype>();
        _proto.PrototypesReloaded += _ => _allSkills = _proto.EnumeratePrototypes<CP14SkillPrototype>();

        _tree = _proto.Index<CP14SkillTreePrototype>("Blacksmithing");
    }

    public void SetPlayer(Entity<CP14SkillStorageComponent>? player)
    {
        _player = player;
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        _hoveredNode = null;
        if (_player == null || _tree == null)
        {
            return;
        }

        var cursor = (UserInterfaceManager.MousePositionScaled.Position * UIScale) - GlobalPixelPosition;
        var playerSkills = _player.Value.Comp.Skills;

        var globalOffset = new Vector2(60, 60);

        //Draw connection lines
        foreach (var skill in _allSkills)
        {
            if (skill.Tree != _tree)
                continue;

            var fromPos = skill.SkillUiPosition * GridSize * UIScale + globalOffset;

            foreach (var prerequisite in skill.Prerequisites)
            {
                if (!_proto.TryIndex(prerequisite, out var prerequisiteSkill))
                    continue;

                var toPos = prerequisiteSkill.SkillUiPosition * GridSize * UIScale + globalOffset;
                var color = playerSkills.Contains(prerequisite) ? Color.White : Color.White;
                handle.DrawLine(fromPos, toPos, color);
            }
        }

        //Draw skill icons over lines
        foreach (var skill in _allSkills)
        {

            if (skill.Tree != _tree)
                continue;

            var texture = skill.Icon.Frame0();
            var pos = skill.SkillUiPosition * GridSize * UIScale + globalOffset;
            var iconSize = new Vector2(texture.Width, texture.Height) * 2;
            var iconQuad = new UIBox2(pos - iconSize / 2, pos + iconSize / 2);

            var hovered = (cursor - pos).LengthSquared() <= (iconSize.X / 2) * (iconSize.X / 2);

            handle.DrawTextureRect(_tree.FrameIcon.Frame0(), iconQuad, Color.White);
            if (hovered)
            {
                _hoveredNode = skill;
                handle.DrawTextureRect(_tree.HoveredIcon.Frame0(), iconQuad, Color.White);
            }
            handle.DrawTextureRect(texture, iconQuad, Color.White);
        }
    }
}
